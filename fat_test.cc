#include "fat.h"
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <functional>
#include <algorithm>
#include <iomanip>
#include <iostream>
#include <string>
#include <fstream>
#include <sstream>
#include <map>

namespace {
bool TEST_DEBUG = false;
int passed_groups = 0, failed_groups = 0;
int passed_total = 0, failed_total = 0;
int passed_in_group = 0, failed_in_group = 0;
std::string saved_category = "";
std::string saved_subtest = "";

std::ofstream myout;


const int big_timeout = 200;

/* This testing script has an option to try fork()ing for each test,
   enabled by this #define. This allows timeouts for individual tests
   (in case of infinite loops) and recovery from crashes on
   individual tests which is handy when using this as a template for
   grading, but mostly confusing when using this for self-testing,
   so it is disabled by default

   The logic for this forking includes logic to save the offsets of
   every file descriptor >= 4 (fds 0 to 3 are stdin, stdout, stderr
   and 'myout') and restore it after waiting on the forked
   subprocess in order to handle cases where code uses the offset
   in a file descriptor to save something like the current working
   directory. (I do not recommmend this approach as it is extremely
   error-prone.)
 */
#ifdef DO_FORK_FOR_TESTS
int nest_level = 0;

std::map<int, off_t> save_fd_offsets() {
    std::map<int, off_t> fd_offsets;
    for (int i = 4; i < 1024; ++i) {
        off_t offset = lseek(i, 0, SEEK_CUR);
        if (offset != -1) {
            fd_offsets[i] = offset;
        }
    }
    return fd_offsets;
}

void restore_fd_offsets(std::map<int, off_t> fd_offsets) {
    for (int i = 0; i < 1024; ++i) {
        if (fd_offsets.count(i)) {
            lseek(i, fd_offsets[i], SEEK_SET);
        }
    }
}

void fork_and_run(std::function<void(void)> f, int timeout=-1) {
    ++nest_level;
    if (nest_level == 1 && timeout == -1) {
        timeout = 5;
    }
    if (nest_level == 2 && timeout == -1) {
        timeout = 3;
    }
    if (nest_level > 3 && timeout == 2) {
        timeout = 1;
    }
    auto offsets = save_fd_offsets();
    if (getenv("FAT_TEST_DO_NOT_FORK") != 0) {
        f();
    } else {
        sigset_t signals;
        sigemptyset(&signals);
        sigaddset(&signals, SIGCHLD);
        sigprocmask(SIG_BLOCK, &signals, NULL);
        myout << std::flush;
        int pid = fork();
        if (pid == 0) {
            sigprocmask(SIG_UNBLOCK, &signals, NULL);
            f();
            myout << std::flush;
            _Exit(0);
        } else {
            siginfo_t info;
            struct timespec to = {
                .tv_sec = (time_t) timeout,
                .tv_nsec = 0,
            };
            int rv = sigtimedwait(&signals, &info, &to);
            if (rv == -1 && errno == EAGAIN) {
                kill(pid, SIGKILL);
                myout << "TEST:TIMEOUT:\n";
                rv = sigtimedwait(&signals, &info, NULL);
                if (rv == -1)
                    abort();
            }
            int status;
            pid_t waited_pid = waitpid(pid, &status, 0);
            if (pid != waited_pid)
                abort();
            if (WIFSIGNALED(status)) {
                myout << "TEST:CRASH:\n";
                myout << std::flush;
            }
        }
        restore_fd_offsets(offsets);
    }
    --nest_level;
}
#else
void fork_and_run(std::function<void(void)> f, int timeout=-1) {
    f();
}
#endif


#define CHECK(x, what) \
    do { \
        myout << "    " << what << ": ";; \
        if (x) { \
            myout << "passed.\n"; \
            ++passed_in_group; \
            ++passed_total; \
        } else { \
            myout << "failed.\n"; \
            ++failed_in_group; \
            ++failed_total; \
        } \
    } while (0)

#ifdef GRADING_OUTPUT
#define TEST(x, category, subtest) \
    do { \
        myout << "TEST:"; \
        if (x) { \
            myout << "PASS:"; \
        } else { \
            myout << "FAIL:"; \
        } \
        myout << category << ":" << subtest << "\n"; \
        myout << std::flush; \
    } while (0)

#define START_TEST_SET(category, subtest) do { \
        passed_in_group = failed_in_group = 0; \
        if (saved_category != "") abort(); \
        saved_category = category; \
        saved_subtest = subtest; \
        myout << "TEST:START:" << category << ":" <<subtest << "\n"; \
        myout << std::flush; \
    } while (0)

#define CHECK_TEST_SET() do { \
        TEST(failed_in_group == 0, saved_category, saved_subtest); \
        passed_in_group = failed_in_group = 0; \
        saved_category = ""; \
        saved_subtest = ""; \
    } while (0)
#else
#define START_TEST_SET(category, subtest) do { \
        passed_in_group = failed_in_group = 0; \
        if (saved_category != "") abort(); \
        saved_category = category; \
        saved_subtest = subtest; \
        myout << "Running test group for " << category ": " << subtest << ":\n"; \
     } while (0)
#define CHECK_TEST_SET() do { \
        std::string result = failed_in_group == 0 ? "PASSED" : "FAILED"; \
        if (failed_in_group == 0) { ++passed_groups; } else { ++failed_groups; } \
        myout << result << " tests for " << saved_category << ": " << saved_subtest << ".\n" \
              << "(" << passed_in_group << " subtests passed and " << failed_in_group << " subtests failed.)\n\n"; \
        saved_category = ""; \
     } while (0)
#endif

#define THISTLE_TEXT \
    "All problems become smaller if you don't dodge them,\n"\
    "but confront them.\n"\
    "Touch a thistle timidly, and it pricks you;\n"\
    "grasp it boldly, and its spines crumble.\n"\
    "\n"\
    "William S. Halsey\n"\
    "\n"\

#define CONGRATS_TEXT  \
    "Congratulations, you have gotten something working!\n"\
    "\n"\
    "Now that you can wade through the FAT with the greatest of ease, you can\n"\
    "undercut all of those $30 shareware \"Undelete\" applications that market\n"\
    "to people with digital camera and USB drive dysfunctions.  Go forth and\n"\
    "take advantage of other people's misfortunes!\n"\
    "\n"\
    "Only $19.99!!!!\n"\
    "\n"\
    "-Duane\n"\
    "\n"

#define THE_GAME_TEXT \
    "Subject: for your amusement\n" \
    "To: csfaculty@uvacs.cs.virginia.edu\n" \
    "Date: Thu, 23 Mar 1995 10:49:33 -0500 (EST)\n" \
    "Content-Type: text/plain; charset=US-ASCII\n" \
    "Content-Transfer-Encoding: 7bit\n" \
    "Status: RO\n" \
    "Content-Length: 4226\n" \
    "\n" \
    "> Software - How Software Companies Die\n" \
    ">         By: Orson Scott Card\n" \
    "> \n" \
    "> The environment that nutures creative programmers kills management\n" \
    "> and marketing types - and vice versa.  Programming is the Great Game.\n" \
    "> It consumes you, body and soul.  When you're caught up in it, nothing\n" \
    "> else matters.  When you emerge into daylight, you might well discover\n" \
    "> that you're a hundred pounds overweight, your underwear is older than\n" \
    "> the average first grader, and judging from the number of pizza boxes\n" \
    "> lying around, it must be spring already.  But you don't care, because\n" \
    "> your program runs, and the code is fast and clever and tight.  You won.\n" \
    "> You're aware that some people think you're a nerd.  So what?  They're\n" \
    "> not players.  They've never jousted with Windows or gone hand to hand\n" \
    "> with DOS. To them C++ is a decent grade, almost a B - not a language.\n" \
    "> They barely exist.  Like soldiers or artists, you don't care about the\n" \
    "> opinions of civilians.  You're building something intricate and fine.\n" \
    "> They'll never understand it.\n" \
    "> \n" \
    "> BEEKEEPING\n" \
    "> \n" \
    "> Here's the secret that every successful software company is based on:\n" \
    "> You can domesticate programmers the way beekeepers tame bees.  You\n" \
    "> can't exactly communicate with them, but you can get them to swarm in\n" \
    "> one place and when they're not looking, you can carry off the honey.\n" \
    "> You keep these bees from stinging by paying them money.  More money\n" \
    "> than they know what to do with.  But that's less than you might think.\n" \
    "> You see, all these programmers keep hearing their parents' voices in\n" \
    "> their heads saying \"When are you going to join the real world?\"  All\n" \
    "> you have to pay them is enough money that they can answer (also in\n" \
    "> their heads) \"Geez, Dad, I'm making more than you.\"  On average, this\n" \
    "> is cheap.  And you get them to stay in the hive by giving them other\n" \
    "> coders to swarm with.  The only person whose praise matters is another\n" \
    "> programmer.  Less-talented programmers will idolize them; evenly\n" \
    "> matched ones will challenge and goad one another; and if you want to\n" \
    "> get a good swarm, you make sure that you have at least one certified\n" \
    "> genius coder that they can all look up to, even if he glances at other\n" \
    "> people's code only long enough to sneer at it. He's a Player, thinks\n" \
    "> the junior programmer.  He looked at my code.  That is enough. If a\n" \
    "> software company provides such a hive, the coders will give up sleep,\n" \
    "> love, health, and clean laundry, while the company keeps the bulk of\n" \
    "> the money.\n" \
    "> \n" \
    "> OUT OF CONTROL\n" \
    "> \n" \
    "> Here's the problem that ends up killing company after company.  All\n" \
    "> successful software companies had, as their dominant personality, a\n" \
    "> leader who nurtured programmers.  But no company can keep such a leader\n" \
    "> forever. Either he cashes out, or he brings in management types who end\n" \
    "> up driving him out, or he changes and becomes a management type himself.\n" \
    "> One way or another, marketers get control.  But...control of what?\n" \
    "> Instead of finding assembly lines of productive workers, they quickly\n" \
    "> discover that their product is produced by utterly unpredictable,\n" \
    "> uncooperative, disobedient, and worst of all, unattractive people who\n" \
    "> resist all attempts at management.  Put them on a time clock, dress\n" \
    "> them in suits, and they become sullen and start sabotaging the product.\n" \
    "> Worst of all, you can sense that they are making fun of you with every\n" \
    "> word they say.\n" \
    "> \n" \
    "> SMOKED OUT\n" \
    "> \n" \
    "> The shock is greater for the coder, though.  He suddenly finds that\n" \
    "> alien creatures control his life.  Meetings, Schedules, Reports.  And\n" \
    "> now someone demands that he PLAN all his programming and then stick to\n" \
    "> the plan, never improving, never tweaking, and never, never touching\n" \
    "> some other team's code. The lousy young programmer who once worshiped\n" \
    "> him is now his tyrannical boss, a position he got because he played\n" \
    "> golf with some sphincter in a suit. The hive has been ruined.  The best\n" \
    "> coders leave.  And the marketers, comfortable now because they're\n" \
    "> surrounded by power neckties and they have things under control, are\n" \
    "> baffled that each new iteration of their software loses market share\n" \
    "> as the code bloats and the bugs proliferate.  Got to get some better\n" \
    "> packaging.  Yeah, that's it.\n" \
    "\n"

static const unsigned char jpg_404_fail_beginning[] = {
 0xff, 0xd8, 0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x01, 0x00, 0x48,
 0x00, 0x48, 0x00, 0x00, 0xff, 0xe1, 0x00, 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x49, 0x49,
 0x2a, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xdb, 0x00, 0x43,
 0x00, 0x08, 0x06, 0x06, 0x07, 0x06, 0x05, 0x08, 0x07, 0x07, 0x07, 0x09, 0x09, 0x08, 0x0a, 0x0c,
 0x14, 0x0d, 0x0c, 0x0b, 0x0b, 0x0c, 0x19, 0x12, 0x13, 0x0f, 0x14, 0x1d, 0x1a, 0x1f, 0x1e, 0x1d,
 0x1a, 0x1c, 0x1c, 0x20, 0x24, 0x2e, 0x27, 0x20, 0x22, 0x2c, 0x23, 0x1c, 0x1c, 0x28, 0x37, 0x29,
 0x2c, 0x30, 0x31, 0x34, 0x34, 0x34, 0x1f, 0x27, 0x39, 0x3d, 0x38, 0x32, 0x3c, 0x2e, 0x33, 0x34,
 0x32, 0xff, 0xdb, 0x00, 0x43, 0x01, 0x09, 0x09, 0x09, 0x0c, 0x0b, 0x0c, 0x18, 0x0d, 0x0d, 0x18,
 0x32, 0x21, 0x1c, 0x21, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32
, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0xff, 0xc2, 0x00, 0x11, 0x08, 0x01, 0x90, 0x01, 0xf4, 0x03
, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11, 0x01, 0xff, 0xc4, 0x00, 0x1b, 0x00, 0x00, 0x02
, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
, 0x03, 0x04, 0x05, 0x02, 0x06, 0x07, 0xff, 0xc4, 0x00, 0x19, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01
, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04
, 0x05, 0xff, 0xda, 0x00, 0x0c, 0x03, 0x01, 0x00, 0x02, 0x10, 0x03, 0x10, 0x00, 0x00, 0x01, 0xf0
, 0x29, 0xf3, 0x2b, 0x11, 0x63, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31
, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03
, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10, 0x31, 0x03, 0x10
, 0x31, 0x03, 0x4d, 0x00, 0x00, 0x1d, 0x9c, 0x16, 0x49, 0xba, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xc5
, 0x90, 0xac, 0x59, 0x0a, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xc5, 0x90
, 0xac, 0x59, 0x0a, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xc5, 0x90, 0xac
, 0x59, 0x0a, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xc5, 0x90, 0xac, 0x59
, 0x0a, 0xc5, 0x90, 0xac, 0x59, 0x0a, 0xea, 0xc5, 0x76, 0x40, 0x2c, 0x00, 0x00, 0x06, 0x9a, 0x00
, 0x02, 0x78, 0x27, 0x9b, 0xf5, 0xf6, 0xe1, 0xd2, 0xf1, 0x62, 0xad, 0x5d, 0x3e, 0xa6, 0x7c, 0xfc
, 0xfa, 0x50, 0xf7, 0xd5, 0x71, 0x5e, 0x32, 0x1e, 0xa7, 0x3a, 0x94, 0xfb, 0xbb, 0x63, 0x0b, 0x93
, 0x65, 0x3f, 0x4d, 0xb1, 0x63, 0x3a, 0x2a, 0xd1, 0xef, 0x12, 0xb1, 0xe8, 0xdf, 0x9a, 0xbd, 0x56
, 0x31, 0xaf, 0xd5, 0xaa, 0x0f, 0xd1, 0xe5, 0x4b, 0x6a, 0xe6, 0x75, 0xad, 0x66, 0x5e, 0x13, 0xb1
, 0x45, 0x63, 0x9a, 0x81, 0x58, 0xe9, 0x29, 0xf7, 0x6f, 0xaa, 0x97, 0x33, 0xd5, 0xf9, 0x8e, 0x7a
, 0x97, 0x33, 0xd2, 0xcf, 0x87, 0x89, 0xbf, 0x6a, 0x3e, 0x72, 0xbc, 0x91, 0x1c, 0xd0, 0x1d, 0xf1
, 0xb2, 0x9a, 0x19, 0x62, 0x38, 0x26, 0x9a, 0xdc, 0xd9, 0x26, 0x87, 0x57, 0x37, 0x27, 0x5b, 0x26
, 0xf4, 0x00, 0xd7, 0x30, 0x00, 0x00, 0x69, 0xa0, 0x00, 0x27, 0x82, 0x79, 0xbf, 0x5f, 0xa1, 0x97
, 0xb1, 0xe2, 0xe7, 0x0c, 0x92, 0xac, 0xe7, 0x77, 0x8b, 0xde, 0x33, 0xd9, 0xaf, 0x4a, 0x79, 0x41
, 0x3d, 0x3f, 0x11, 0xe3, 0x1b, 0x98, 0x1b, 0xde, 0x74, 0xc0, 0xd2, 0xa1, 0xea, 0x23, 0xcb, 0xc7
, 0xe9, 0x30, 0x77, 0x62, 0x92, 0x2b, 0x1b, 0x68, 0x5a, 0xc6, 0x9f, 0x53, 0x5b, 0xa8, 0x6c, 0xee
, 0x6f, 0x79, 0x9f, 0x4b, 0xe4, 0x33, 0xab, 0xc9, 0xad, 0xe1, 0x8d, 0xab, 0x7c, 0xb4, 0x7d, 0x26
, 0x48, 0x93, 0x4d, 0x9c, 0x6d, 0x3c, 0x5c, 0x5d, 0x5a, 0x5b, 0xb7, 0x73, 0xbf, 0x1f, 0x47, 0xd3
, 0x79, 0x5e, 0x59, 0xeb, 0x87, 0x1e, 0x04, 0x52, 0xc3, 0xa7, 0x07, 0x72, 0xdb, 0xc9, 0x0f, 0x4b
, 0xcf, 0x53, 0xc2, 0x66, 0xe3, 0xeb, 0x64, 0xde, 0x80, 0x1a, 0xc0, 0x00, 0x00, 0x34, 0xd0, 0x00
, 0x13, 0xc1, 0x3c, 0xdf, 0xa9, 0xb9, 0x4e, 0xff, 0x00, 0x9b, 0x94, 0xbc, 0xd6, 0xed, 0x3d, 0xef
, 0x93, 0xf4, 0x58, 0x1d, 0xaf, 0x9b, 0xe7, 0x5f, 0x27, 0x4f, 0x73, 0xe3, 0xbd, 0xe7, 0xcf, 0x2b
, 0xd4, 0xe2, 0x5f, 0xa1, 0x19, 0x1e, 0x87, 0x1b, 0x5f, 0x32, 0x4f, 0x35, 0xe9, 0x7c, 0xdc, 0xae
, 0x5a, 0x12, 0xf6, 0xb6, 0xb4, 0xea, 0xe9, 0x6b, 0x32, 0xf4, 0xf9, 0xde, 0x76, 0x7c, 0xef, 0xa0
, 0xc0, 0x9a, 0xe9, 0x75, 0xc5, 0x8f, 0xa8, 0x82, 0x55, 0x18, 0x4f, 0x2d, 0x5e, 0xd2, 0x5e, 0x94
, 0x84, 0xb9, 0x36, 0xb2, 0xf2, 0xf4, 0x5c, 0xe7, 0x75, 0x75, 0xd5, 0x5a, 0xe7, 0x9d, 0xdc, 0x90
, 0x73, 0xc9, 0x7b, 0x21, 0x47, 0xaa, 0xe3, 0x3a, 0xe9, 0x5f, 0x51, 0x00, 0x73, 0xc5, 0xb5, 0xb3
, 0x34, 0xb3, 0x5d, 0x00, 0x2f, 0x30, 0x00, 0x00, 0x69, 0xa0, 0x00, 0x27, 0x82, 0x79, 0xbf, 0x47
, 0xa7, 0x85, 0x73, 0x96, 0x36, 0xa9, 0xf1, 0x73, 0x96, 0x3d, 0x2d, 0x4b, 0x10, 0xf6, 0xb4, 0x3c
, 0xcf, 0xa3, 0xc5, 0x93, 0x5f, 0xce, 0xea, 0xe6, 0xf7, 0xd4, 0xbb, 0x1e, 0x77, 0xd1, 0x49, 0x9b
, 0x34, 0x55, 0x73, 0x9e, 0xea, 0xde, 0x4d, 0xc5, 0x4b, 0x5a, 0x9d, 0x2b, 0xd3, 0x4d, 0xd3, 0x3d
, 0x38, 0xe6, 0xd4, 0xd2, 0xca, 0xbb, 0xdc, 0xd6, 0x6c, 0x32, 0x3b, 0x28, 0xdb, 0xb1, 0x12, 0x0e
, 0x27, 0x5d, 0x73, 0xcb, 0x4e, 0xef, 0xd0, 0x98, 0xb3, 0xe7, 0x7d, 0x25, 0x0c, 0x28, 0x57, 0xf5
, 0x7e, 0x63, 0x3d, 0x2b, 0x12, 0x2e, 0x73, 0x8e, 0x6c, 0xc3, 0x11, 0xf2, 0xfb, 0xb6, 0x35, 0x60
, 0x8a, 0xb2, 0x74, 0x55, 0x74, 0xd6, 0xad, 0x3c, 0xed, 0x2c, 0xd9, 0xd0, 0x03, 0x5c, 0xc0, 0x00
, 0x01, 0xa6, 0x80, 0x00, 0x9e, 0x09, 0xe6, 0xfd, 0x0d, 0xa8, 0x74, 0x70, 0xae, 0xbb, 0x81, 0x3d
, 0x96, 0x97, 0x95, 0xc9, 0x6b, 0xd9, 0xd4, 0xf2, 0x35, 0xeb, 0xd8, 0x68, 0xfc, 0xeb, 0x57, 0x79
, 0xf5, 0x38, 0x77, 0xb1, 0x59, 0xb0, 0xe5, 0xee, 0x6e, 0x36, 0x45, 0x2f, 0x3a, 0x3d, 0x47, 0xbe
, 0x77, 0xe0, 0xbf, 0xb2, 0x7c, 0x8f, 0x7b, 0xd4, 0xe2, 0x35, 0x7a, 0x3a, 0x5e, 0xbe, 0xe2, 0x83
, 0xd3, 0x32, 0xcd, 0x7a, 0x14, 0x97, 0x9a, 0x1e, 0x6f, 0x17, 0x3d, 0xbd, 0x5d, 0xaf, 0x0f, 0xcd
, 0x9e, 0xd6, 0x3f, 0x1f, 0xca, 0xfb, 0x3b, 0x5e, 0x06, 0xf3, 0x3a, 0x99, 0x3b, 0x91, 0xeb, 0x8e
, 0x24, 0x9b, 0x97, 0x63, 0xca, 0x2f, 0x60, 0xb5, 0x3c, 0xaf, 0x16, 0xf3, 0xb9, 0xea, 0xd7, 0x71
, 0x2c, 0xac, 0x54, 0x8d, 0x2f, 0x11, 0xcf, 0xc6, 0xd4, 0xb3, 0xf4, 0xf3, 0x1d, 0x00, 0x2f, 0x30
, 0x00, 0x00, 0x69, 0xa0, 0x00, 0x27, 0x82, 0x79, 0xbf, 0x4f, 0x72, 0x86, 0x97, 0x3d, 0x71, 0x15
, 0x99, 0x24, 0x5e, 0x6b, 0xd4, 0x79, 0x9b, 0xd5, 0x29, 0x62, 0xba, 0xe5, 0x4c, 0xae, 0x22, 0x92
, 0x3e, 0x6e, 0x26, 0x94, 0xbb, 0x8f, 0x45, 0x43, 0x4a, 0xbd, 0xb4, 0xa7, 0xb3, 0x9b, 0x71, 0xee
, 0xae, 0x78, 0x5a, 0x5d, 0xbc, 0x9e, 0xef, 0xc8, 0x54, 0x73, 0x57, 0xfd, 0xa7, 0xce, 0xa4, 0xce
, 0xbd, 0x74, 0x59, 0x9a, 0x0c, 0xbc, 0x5f, 0x4b, 0xe5, 0x26, 0xe3, 0x96, 0x2f, 0xa1, 0x63, 0xd3
, 0xe1, 0x0f, 0x59, 0xe5, 0x6f, 0x35, 0x46, 0xec, 0x29, 0x0c, 0xdc, 0x49, 0xcf, 0xd7, 0x6b, 0xb0
, 0xef, 0xf3, 0x77, 0xed, 0xf9, 0x75, 0xae, 0x7e, 0xaf, 0x8f, 0x3b, 0x02, 0x7a, 0x7f, 0x37, 0x96
, 0x5b, 0xdc, 0x71, 0xa9, 0x7b, 0xe7, 0x94, 0x75, 0x24, 0x44, 0xb0, 0x65, 0x68, 0xe7, 0x67, 0x60
, 0x17, 0x00, 0x00, 0x00, 0xd3, 0x40, 0x00, 0x4f, 0x04, 0xf3, 0x7e, 0xab, 0x56, 0xbe, 0xb7, 0x9b
, 0xad, 0x52, 0xd7, 0x58, 0xb4, 0x31, 0xfd, 0x2d, 0x0e, 0xd9, 0xf3, 0x4f, 0x72, 0x97, 0x49, 0x27
, 0x3d, 0x47, 0xae, 0x55, 0x29, 0xea, 0x93, 0x75, 0x26, 0xed, 0x4b, 0xc5, 0x6b, 0xaf, 0x72, 0xb5
, 0x7d, 0x59, 0xe5, 0xc8, 0xe7, 0x4b, 0xae, 0x9c, 0xb3, 0x95, 0xe2, 0xc8, 0x6d, 0xd1, 0xb7, 0xcf
, 0xd3, 0xc5, 0x7f, 0x41, 0xc5, 0xe5, 0x93, 0x53, 0x5f, 0xa9, 0x70, 0xbd, 0x85, 0x0a, 0x16, 0x6a
, 0x64, 0x4f, 0x29, 0x53, 0x9d, 0x9d, 0x1c, 0xeb, 0xcc, 0x59, 0xf5, 0x7d, 0x4e, 0x9e, 0x6f, 0x3f
, 0x7b, 0x03, 0xa7, 0x98, 0xe3, 0xae, 0x10, 0x92, 0x27, 0x16, 0xe7, 0xcd, 0x7c, 0xb7, 0x7a, 0x96
, 0x8d, 0xab, 0x30, 0x65, 0xd8, 0x7b, 0x99, 0x3d, 0xdc, 0x96, 0x3c, 0x76, 0x4e, 0xf6, 0x0b, 0xa0
, 0x05, 0xe6, 0x00, 0x00, 0x0d, 0x34, 0x00, 0x04, 0xf0, 0x4f, 0x37, 0xef, 0xf4, 0xf1, 0x35, 0xbc
, 0x7e, 0x89, 0xf8, 0x83, 0xac, 0xa4, 0x9a, 0x8b, 0xd4, 0xb7, 0x91, 0xde, 0x57, 0xab, 0x87, 0x35
, 0xaf, 0xf2, 0x45, 0xbd, 0x87, 0x7e, 0xcb, 0x7b, 0x19, 0x1a, 0x59, 0xcd, 0x0e, 0xf8, 0xa3, 0xa9
, 0xc6, 0xe7, 0x99, 0xd4, 0xdd, 0xab, 0x8b, 0xb1, 0x53, 0x53, 0x3c, 0xbd, 0x76, 0x6f, 0x0a, 0xde
, 0x97, 0x38, 0xef, 0x91, 0xd7, 0xaf, 0x37, 0xe6, 0xca, 0xb7, 0x43, 0x58, 0xaf, 0x67, 0x2e, 0xaa
, 0x69, 0x6e, 0xf9, 0x2e, 0xb3, 0x7e, 0x83, 0x85, 0x81, 0x69, 0x7d, 0xb9, 0xe3, 0xe2, 0x57, 0x8b
, 0xa7, 0x95, 0x72, 0xf9, 0xe9, 0x58, 0x26, 0x08, 0x60, 0x9b, 0x67, 0x0f, 0xa1, 0x64, 0x22, 0x66
, 0x3e, 0x3e, 0xbe, 0x46, 0x36, 0x01, 0x70, 0x00, 0x00, 0x0d, 0x34, 0x00, 0x04, 0xf0, 0x4f, 0x37
, 0xed, 0xb4, 0x72, 0x2f, 0x79, 0xba, 0xcc, 0xa9, 0x43, 0x65, 0xba, 0xd5, 0xd6, 0xf3, 0x2e, 0x65
, 0xda, 0xba, 0x5b, 0x79, 0x7d, 0xe9, 0x77, 0x57, 0xa6, 0xe7, 0xab, 0xb3, 0xe2, 0xf7, 0x3e, 0x37
, 0x4d, 0x1f, 0x1d, 0xb3, 0xe5, 0x7a, 0xe2, 0x38, 0x36, 0x57, 0xd0, 0xe9, 0x0d, 0xbd, 0x3e, 0xfa
, 0x73, 0xa3, 0x99, 0xce, 0x85, 0xd7, 0x9e, 0x9f, 0xdc, 0xf5, 0x73, 0xf3, 0xdb, 0x5e, 0xd6, 0xa5
, 0x54, 0xc6, 0x93, 0x89, 0xac, 0x97, 0x3c, 0x78, 0xed, 0xc7, 0x73, 0x17, 0x31, 0x59, 0xe9, 0x35
, 0xaf, 0xc6, 0x64, 0xfa, 0xe3, 0xdd, 0x49, 0xea, 0x5e, 0x73, 0x3e, 0x0b, 0x3b, 0x7c, 0xb3, 0xb7
, 0x1f, 0x47, 0x42, 0x60, 0x0c, 0x17, 0x4d, 0x70, 0xf2, 0xb5, 0xb2, 0x71, 0xb4, 0x05, 0xc0, 0x00
, 0x00, 0x34, 0xd0, 0x00, 0x13, 0xc1, 0x3c, 0xdf, 0xa5, 0xb7, 0x56, 0xd7, 0x2b, 0xc4, 0x12, 0xd4
, 0xb2, 0x4e, 0x23, 0xe7, 0x49, 0x38, 0xe0, 0xb2, 0x09, 0x63, 0xb9, 0x9e, 0xda, 0xd2, 0xcf, 0x1e
, 0xf9, 0xe4, 0x2d, 0xc5, 0x37, 0x81, 0x4b, 0xd0, 0x4f, 0x71, 0x99, 0x3c, 0xf9, 0x59, 0xce, 0x95
, 0xff, 0x00, 0x39, 0x7b, 0x36, 0x5d, 0xcc, 0x4b, 0xb6, 0xfa, 0x2b, 0x7e, 0x63, 0xb6, 0x7d, 0x0c
, 0x78, 0x67, 0x46, 0x87, 0x92, 0xb9, 0x4d, 0x29, 0x7d, 0x0b, 0xc1, 0xec, 0x94, 0xb1, 0xf6, 0x39
, 0x6a, 0x9b, 0xd8, 0xa4, 0xb4, 0xf8, 0x95, 0xdc, 0xd3, 0xef, 0xb8, 0xe2, 0x76, 0x17, 0x9b, 0x13
, 0x56, 0x22, 0x98, 0x98, 0xdf, 0x2c, 0xe9, 0xf0, 0xd7, 0x1b, 0x23, 0x5f, 0x23, 0x1b, 0x00, 0xb8
, 0x00, 0x00, 0x06, 0x9a, 0x00, 0x02, 0x78, 0x27, 0x9b, 0xdb, 0xd0, 0xcf, 0x9b, 0x15, 0xc1, 0xca
, 0xb9, 0xe5, 0x49, 0x68, 0xa9, 0x3f, 0xa1, 0xeb, 0xcf, 0xd3, 0x2b, 0x23, 0x7b, 0x0b, 0x5b, 0xb3
, 0x35, 0x6b, 0x3d, 0x35, 0xcc, 0x33, 0x49, 0xae, 0x34, 0xa2, 0xd7, 0xcc, 0xd2, 0x07, 0x34, 0x39
, 0xea, 0xf5, 0xe9, 0x6a, 0xf2, 0x62, 0xdf, 0x8e, 0x9a, 0x4d, 0x34, 0xf3, 0x4b, 0x9b, 0x5b, 0x47
, 0x2f, 0x77, 0xb5, 0x24, 0x3b, 0x58, 0xeb, 0xba, 0xfb, 0xe3, 0xc1, 0x1f, 0xa1, 0xcf, 0x4c, 0x29
, 0xab, 0x29, 0xa9, 0xdc, 0x52, 0xe3, 0xbb, 0xee, 0x09, 0xba, 0xf9, 0x2c, 0xb8, 0x5e, 0xbc, 0xf2
, 0x91, 0x84, 0x84, 0x65, 0x48, 0xb9, 0x67, 0x49, 0x74, 0xbd, 0x03, 0x31, 0x72, 0x35, 0xf2, 0x31
, 0xb0, 0x0b, 0x80, 0x00, 0x00, 0x69, 0xa0, 0x00, 0x27, 0x82, 0x79, 0xbd, 0xeb, 0x51, 0x6c, 0x70
, 0xde, 0x5f, 0x5e, 0xc6, 0xff, 0x00, 0x95, 0xe5, 0xa7, 0x58, 0xf8, 0xed, 0x6f, 0x36, 0x07, 0xeb
, 0xe1, 0x17, 0x53, 0xc9, 0xdb, 0x39, 0xee, 0x4a, 0xfa, 0xd7, 0x7c, 0x73, 0xc9, 0x34, 0x5a, 0x98
, 0x96, 0x4c, 0x54, 0x52, 0xdb, 0x9f, 0x34, 0x4b, 0xda, 0x18, 0x24, 0x6a, 0x71, 0x9c, 0x5b, 0xb1
, 0x52, 0x99, 0x2d, 0xc2, 0x9b, 0xad, 0xfa, 0xb4, 0xec, 0xeb, 0x30, 0x28, 0x37, 0xf3, 0xac, 0x79
, 0x6e, 0x74, 0x67, 0xc9, 0x73, 0x23, 0x3d, 0x27, 0x9e, 0xad, 0x9e, 0x9c, 0x3b, 0x68, 0xbc, 0xfa
, 0x7c, 0x87, 0x6f, 0x96, 0x74, 0x72, 0xce, 0x84, 0xed, 0x6d, 0x06, 0x46, 0x4e, 0xae, 0x56, 0x36
, 0x01, 0x70, 0x00, 0x00, 0x0d, 0x34, 0x00, 0x04, 0xf0, 0x4f, 0x37, 0xf4, 0xcf, 0x4b, 0x81, 0x73
, 0xe6, 0x6b, 0x47, 0x17, 0x2f, 0x37, 0x1a, 0xae, 0xbb, 0xb1, 0xf4, 0x79, 0xc3, 0xdc, 0x99, 0xfb
, 0xcc, 0xd4, 0x78, 0x5b, 0x81, 0xcf, 0x21, 0xc1, 0xc0, 0x70, 0x23, 0x95, 0xd0, 0x72, 0x30, 0x40
, 0x50, 0x00, 0x00, 0x00, 0x03, 0x5d, 0x9d, 0x7a, 0xcf, 0x27, 0x26, 0x67, 0xa0, 0xe7, 0x0a, 0x53
, 0x6b, 0x0f, 0xbe, 0x6b, 0xb9, 0x78, 0xee, 0xba, 0x69, 0x87, 0x49, 0x8d, 0xa6, 0x36, 0x9d, 0x0c
, 0x60, 0xd3, 0x31, 0xf2, 0x75, 0xb2, 0x71, 0xd0, 0x02, 0xe0, 0x00, 0x00, 0x1a, 0x68, 0x00, 0x09
, 0xe0, 0x9e, 0x6f, 0xd8, 0xcf, 0x47, 0xd0, 0x79, 0x3a, 0xe4, 0xd9, 0xde, 0xcf, 0xde, 0x28, 0x67
, 0x49, 0x5b, 0xbf, 0x3a, 0xb1, 0xdb, 0xe7, 0x52, 0x9f, 0x37, 0x39, 0x29, 0xf3, 0x6b, 0x92, 0xa7
, 0x37, 0x11, 0x4c, 0xb4, 0x8a, 0xaa, 0xd7, 0x25, 0x72, 0xc2, 0xb2, 0x02, 0x64, 0x44, 0xa5, 0x4b
, 0x19, 0x22, 0x38, 0x3a, 0x0e, 0x7b, 0x72, 0x47, 0x5c, 0xc8, 0x24, 0x7d, 0x74, 0xe9, 0x48, 0x74
, 0x3e, 0x93, 0x3a, 0x6b, 0xa0, 0x63, 0x1b, 0x45, 0x3e, 0xb9, 0xe8, 0x06, 0x03, 0x4c, 0xc7, 0xc9
, 0xd6, 0xc9, 0xc7, 0x40, 0x0b, 0x80, 0x00, 0x00, 0x69, 0xa0, 0x00, 0x27, 0x82, 0x79, 0xbf, 0xa0
, 0x6d, 0x79, 0xee, 0x79, 0x5b, 0x59, 0x32, 0xf1, 0xd7, 0x1c, 0x73, 0xd2, 0xb3, 0x85, 0x22, 0x22
, 0xe6, 0x6e, 0x52, 0x25, 0x32, 0x21, 0x53, 0xf2, 0x42, 0xa6, 0x55, 0x0a, 0x99, 0x44, 0x4a, 0x65
, 0x51, 0x29, 0x42, 0x25, 0x30, 0x42, 0x4c, 0x8a, 0xea, 0x74, 0x44, 0xfb, 0x0e, 0x0e, 0x81, 0xbe
, 0x7a, 0x3a, 0xe9, 0x76, 0x0f, 0xae, 0x93, 0x87, 0xdb, 0x22, 0x72, 0x0b, 0x1b, 0xe8, 0xa4, 0x30
, 0x1a, 0x63, 0x68, 0x32, 0x32, 0x75, 0xb2, 0x71, 0xd0, 0x02, 0xe0, 0x00, 0x00, 0x1a, 0x68, 0x00
, 0x09, 0xe0, 0x9e, 0x6f, 0xd2, 0x5c, 0xa9, 0x75, 0x9e, 0x39, 0xef, 0x9b, 0x38, 0x52, 0x23, 0x85
, 0xdf, 0x35, 0xc2, 0xeb, 0x84, 0x39, 0x39, 0x3a, 0x38, 0x44, 0x8b, 0x96, 0x07, 0x40, 0x8e, 0x94
, 0x72, 0x05, 0x23, 0xa0, 0xe7, 0x89, 0x38, 0x11, 0xd8, 0x46, 0xa4, 0x08, 0xb9, 0x99, 0x11, 0x3e
, 0x81, 0x36, 0x1d, 0x75, 0xc3, 0xae, 0xdf, 0x0c, 0xed, 0xf0, 0x47, 0x6f, 0x87, 0x52, 0x1c, 0x30
, 0x06, 0x26, 0x06, 0x46, 0x4e, 0xb6, 0x4e, 0x3a, 0x00, 0x5c, 0x00, 0x00, 0x03, 0x4d, 0x00, 0x01
, 0x3c, 0x13, 0xcd, 0x7a, 0x4b, 0x99, 0x13, 0x35, 0xa2, 0xf3, 0x52, 0x68, 0xac, 0xf4, 0x5f, 0x54
, 0x39, 0x4b, 0xdc, 0x54, 0x4b, 0x6b, 0x8a, 0xea, 0xcb, 0x0a, 0xba, 0x2c, 0x95, 0x99, 0x65, 0xd4
, 0x65, 0xa2, 0xa0, 0x5c, 0x2a, 0x05, 0xb2, 0xa0, 0x59, 0x2a, 0xb2, 0xd9, 0x54, 0x2d, 0x15, 0x42
, 0xca, 0xae, 0x13, 0x90, 0x22, 0x77, 0x5c, 0x2c, 0x3a, 0xc1, 0x68, 0xaa, 0x16, 0xca, 0xa1, 0x6b
, 0xaa, 0x6c, 0xb6, 0xe9, 0x85, 0xd7, 0x49, 0x97, 0x1d, 0x22, 0xaa, 0x64, 0xea, 0x65, 0xe7, 0x40
, 0x17, 0x98, 0x00, 0x00, 0x34, 0xd0, 0x00, 0x00, 0x0c, 0x40, 0xc5, 0x62, 0x6a, 0x5a, 0x9b, 0x38
, 0xf8, 0xf5, 0x4b, 0x25, 0x9a, 0x64, 0x0a, 0xed, 0x4d, 0x70, 0xb1, 0x0e, 0xb6, 0x56, 0x7d, 0x11
, 0x77, 0x1b, 0xdf, 0x8e, 0xfc, 0x57, 0xf1, 0xb1, 0xec, 0xb6, 0xb8, 0xee, 0xe1, 0xf3, 0x34, 0x73
, 0x7d, 0x2e, 0xf9, 0x9a, 0xa9, 0x25, 0x9a, 0xba, 0xe1, 0x66, 0x3b, 0x79, 0x53, 0xa5, 0x97, 0x1f
, 0x3a, 0xe5, 0x60, 0x6b, 0x1d, 0x97, 0x55, 0xef, 0xd5, 0x7e, 0x63, 0xd0, 0x5c, 0xab, 0x51, 0x4f
, 0x79, 0x71, 0x56, 0xe5, 0x2b, 0x8b, 0x90, 0x58, 0xab, 0x2f, 0x53, 0xdb, 0xca, 0x6e, 0xd4, 0x71
, 0xce, 0xc4, 0xb5, 0x74, 0xf2, 0xf3, 0xda, 0x6e, 0x64, 0xa9, 0xbe, 0x48, 0x46, 0xbc, 0xed, 0x00
, 0x00, 0x00, 0x00, 0x03, 0x4d, 0x00, 0x00, 0x00, 0x00, 0x77, 0x65, 0x4d, 0x8f, 0x4d, 0x9c, 0xcd
};



bool is_long_name(const AnyDirEntry &entry) {
    return (entry.dir.DIR_Attr & DirEntryAttributes::LONG_NAME_MASK) == DirEntryAttributes::LONG_NAME;
}

void _check_root_dir(const std::string &path, bool hard = true) {
    START_TEST_SET("readdir of root dir", "path=" + path);
    bool saw_people = false;
    bool saw_congrats = false;
    bool saw_example1 = false;
    bool saw_examp999 = false;
    bool saw_a1 = false;
    bool saw_a2 = false;
    bool saw_a3 = false;
    bool saw_a99 = false;
    for (AnyDirEntry entry : fat_readdir(path)) {
        if (!is_long_name(entry)) {
            std::string name((char*) entry.dir.DIR_Name, (char*) entry.dir.DIR_Name + 11);
            if (name == "PEOPLE     ") {
                saw_people = true;
                CHECK(entry.dir.DIR_Attr & DirEntryAttributes::DIRECTORY, "people is a directory");
            } else if (name == "CONGRATSTXT") {
                saw_congrats = true;
            } else if (name == "EXAMPLE1TXT") {
                saw_example1 = true;
            } else if (name == "EXAMP999TXT") {
                saw_examp999 = true;
            } else if (name == "A1         ") {
                saw_a1 = true;
            } else if (name == "A2         ") {
                saw_a2 = true;
            } else if (name == "A3         ") {
                saw_a3 = true;
            } else if (name == "A99        ") {
                saw_a99 = true;
            }
        }
    }
    CHECK(saw_people, "people directory was found in " << path);
    CHECK(saw_congrats, "congrats.txt was found in " << path);
    CHECK(saw_a1, "a1 was found in " << path);
    CHECK(saw_example1, "example1 was found in " << path);
    CHECK_TEST_SET();
    if (hard) {
        START_TEST_SET("readdir of root dir -- past 0xE5", "path=" + path);
        CHECK(saw_a3 && saw_a99, "A3 and A99 was found in " << path);
        CHECK_TEST_SET();
        START_TEST_SET("readdir of root dir -- multiple clusters", "path=" + path);
        CHECK(saw_a2 && saw_examp999, "A2 and EXAMP999.TXT was found in " << path);
        CHECK_TEST_SET();
    }
}
void check_root_dir(const std::string &path, bool hard = false) {
    fork_and_run(std::bind(&_check_root_dir, path, hard));
}

void _check_yyz5w_dir(const std::string &path) {
    START_TEST_SET("readdir of yyz5w", "path=" + path);
    bool saw_the_game_txt = false;
    bool saw_extra = false;
    for (AnyDirEntry entry : fat_readdir(path)) {
        if (entry.dir.DIR_Name[0] == 0)
            break;
        if (entry.dir.DIR_Name[0] == 0xE5)
            continue;
        if (!is_long_name(entry) && !(entry.dir.DIR_Attr & (DirEntryAttributes::SYSTEM | DirEntryAttributes::HIDDEN))) {
            std::string name((char*) entry.dir.DIR_Name, (char*) entry.dir.DIR_Name + 11);
            if (name == "THE-GAMETXT") {
                saw_the_game_txt = true;
            } else if (name == ".          ") {
            } else if (name == "..         ") {
            } else {
                saw_extra = true;
            }
        }
    }
    CHECK(saw_the_game_txt, "the-game.txt found in " << path);
    CHECK(!saw_extra, "extra NOT found in " << path);
    CHECK_TEST_SET();
}

void check_yyz5w_dir(const std::string &path) {
    fork_and_run(std::bind(&_check_yyz5w_dir, path));
}

void _check_people_dir(const std::string &path) {
    START_TEST_SET("readdir of people", "path=" + path);
    bool saw_yyz5w = false;
    bool saw_smb3wk = false;
    bool saw_example2 = false;
    bool saw_congrats = false;
    for (AnyDirEntry entry : fat_readdir(path)) {
        if (!is_long_name(entry)) {
            std::string name((char*) entry.dir.DIR_Name, (char*) entry.dir.DIR_Name + 11);
            if (name == "YYZ5W      ") {
                saw_yyz5w = true;
            } else if (name == "SMB3WK     ") {
                saw_smb3wk = true;
            } else if (name == "EXAMPLE2TXT") {
                saw_example2 = true;
            } else if (name == "CONGRATSTXT") {
                saw_congrats = true;
            }
        }
    }
    CHECK(saw_example2, "example2 found in " << path);
    CHECK(saw_yyz5w, "yyz5w found in " << path);
    CHECK(saw_smb3wk, "smb3wk found in " << path);
    CHECK(!saw_congrats, "congrats.txt NOT in " << path);
    CHECK_TEST_SET();
}

void check_people_dir(const std::string &path) {
    fork_and_run(std::bind(&_check_people_dir, path));
}

void _check_a99(const std::string &path) {
    bool saw_foo_xx = false;
    START_TEST_SET("readdir of a99", "path=" + path);
    for (AnyDirEntry entry : fat_readdir(path)) {
        if (!is_long_name(entry)) {
            std::string name((char*) entry.dir.DIR_Name, (char*) entry.dir.DIR_Name + 11);
            if (name == "FOO     XX ") {
                saw_foo_xx = true;
            }
        }
    }
    CHECK(saw_foo_xx, "foo.xx found in " << path);
    CHECK_TEST_SET();
}

void check_a99(const std::string &path) {
    fork_and_run(std::bind(&_check_a99, path));
}

void _check_a2(const std::string &path) {
    START_TEST_SET("readdir of a2", "path=" + path);
    bool saw_example3 = false;
    for (AnyDirEntry entry : fat_readdir(path)) {
        if (!is_long_name(entry)) {
            std::string name((char*) entry.dir.DIR_Name, (char*) entry.dir.DIR_Name + 11);
            if (name == "EXAMPLE3TXT") {
                saw_example3 = true;
            }
        }
    }
    CHECK(saw_example3, "example3 found in " << path);
    CHECK_TEST_SET();
}

void check_a2(const std::string &path) {
    fork_and_run(std::bind(&_check_a2, path));
}

void _check_b4(const std::string &path) {
    START_TEST_SET("readdir of b4", "path=" + path);
    bool saw_example8 = false;
    bool saw_example9 = false;
    for (AnyDirEntry entry : fat_readdir(path)) {
        if (!is_long_name(entry)) {
            std::string name((char*) entry.dir.DIR_Name, (char*) entry.dir.DIR_Name + 11);
            if (TEST_DEBUG) myout << "CHECKING [" << name << "]" << std::endl;
            if (name == "EXAMPLE9TXT") {
                saw_example9 = true;
            } else if (name == "EXAMPLE8TXT") {
                saw_example8 = true;
            }
        }
    }
    CHECK(saw_example8, "example8 found in " << path);
    CHECK(saw_example9, "example9 found in " << path);
    CHECK_TEST_SET();
}

void check_b4(const std::string &path) {
    fork_and_run(std::bind(&_check_b4, path));
}

void hex_dump(const std::string &buffer) {
    std::ios_base::fmtflags saved_fmt_flags(myout.flags());
    myout << std::setw(13)  << std::left << "start byte#" << std::right << " values as hexadecimal\n";
    const unsigned per_line = 32;
    for (unsigned i = 0; i < buffer.size(); i += per_line) {
        myout << std::hex << std::showbase << std::left << std::setw(13) << i << std::noshowbase << std::right;
        for (unsigned j = i; j < i + per_line && j < buffer.size(); ++j) {
            myout << " " <<std::hex << std::setw(2) << std::setfill('0') << (static_cast<int>(buffer[j]) & 0xFF) << std::setfill(' ');
        }
        myout << "\n";
    }
    myout.flags(saved_fmt_flags);
}

void dump_for_compare(const std::string &expected, const std::string &actual) {
    bool all_text = true;
    for (char c : expected) {
        if (!std::isprint(c) && !std::isspace(c)) all_text = false;
    }
    for (char c : actual) {
        if (!std::isprint(c) && !std::isspace(c)) all_text = false;
    }
    if (all_text) {
        myout << "---expected result---\n";
        myout << expected;
        myout << "---end of expected result---\n";
        myout << "---actual result---\n";
        myout << actual;
        myout << "---end of actual result---\n";
    } else {
        myout << "expected and/or actual result contains non-printable characters, displaying as hexadecimal\n";
        myout << "---expected result---\n";
        hex_dump(expected);
        myout << "---end of expected result---\n";
        myout << "---actual result---\n";
        hex_dump(actual);
        myout << "---end of actual result---\n";
    }
}

void check_pread_ranges(int fd, const std::string &expected, const std::string &scenario, bool check_excess = true) {
    if (check_excess) {
        START_TEST_SET("pread with various offsets and counts, contents/size/not exceeding buffer", scenario);
    } else {
        START_TEST_SET("pread with various offsets and counts, contents/size", scenario);
    }
    if (fd == -1) {
        CHECK(false, "fd for pread is -1");
    } else {
        char buffer[16 * 1024 + 512];
        for (unsigned raw_offset = 0; raw_offset < expected.size() + 1024; raw_offset += 1024) {
            for (unsigned offset = raw_offset > 1 ? raw_offset - 1 : 0u; offset <= raw_offset + 1; ++offset) {
                for (unsigned raw_count = 0; raw_count < sizeof(buffer) - 4 && raw_count < expected.size() + 1024; raw_count += 1024) {
                    for (unsigned count = raw_count > 2 ? raw_count - 2 : 0u; count <= raw_count + 2; ++count) {
                        memset(buffer, 'X', sizeof buffer);
                        int read_count = fat_pread(fd, (void*) buffer, count, offset);
                        int expected_count = std::max(0, std::min((int) count, (int) (expected.size() - offset)));
                        CHECK(read_count == expected_count, "pread return value, offset=" << offset << ",count=" << count 
                                << ",expected=" << expected_count << ",actual=" << read_count);
                        unsigned real_offset = offset >= expected.size() ? 0 : offset;
                        std::string actual_result(buffer, buffer + expected_count);
                        std::string expected_result(expected.begin() + real_offset, expected.begin() + expected_count + real_offset);
                        if (actual_result != expected_result) {
                            CHECK(false, "pread contents offset=" << offset << ",count=" << count << " [comparison follows if failure]");
                            dump_for_compare(expected_result, actual_result);
                        }
                        if (check_excess)
                            CHECK(*(buffer + expected_count + 4) == 'X', "pread does not go past end of buffer");
                    }
                }
            }
        }
    }
    CHECK_TEST_SET();
}

void _check_pread_simple(int fd, const std::string &expected, const std::string &scenario, bool include_size = false) {
    std::vector<char> buffer;
    if (fd == -1) {
        CHECK(false, scenario << ": no fd");
    }
    buffer.resize(expected.size() + 4096);
    buffer[expected.size()] = 'X';
    int read_count = fat_pread(fd, &buffer[0], include_size ? expected.size() + 1024 : expected.size(), 0);
    CHECK(std::string(buffer.begin(), buffer.begin() + expected.size()) == expected, scenario << ": contents [comparison follows if failure]");
    if (std::string(buffer.begin(), buffer.begin() + expected.size()) != expected) {
        dump_for_compare(expected, std::string(buffer.begin(), buffer.begin() + expected.size()));
    }
    if (include_size) {
        CHECK(read_count == (int) expected.size(), scenario << ": size");
        CHECK(buffer[expected.size()] == 'X', scenario << ": no writing from past end of file");
    }
}

void _check_contents(const std::string &path, const std::string &contents, bool only_simple = true) {
    std::string scenario = "path="+path;
    START_TEST_SET("simple open+read", scenario);
    int fd = fat_open(path);
    CHECK(fd >= 0, "opening " << path);
    if (fd >= 0) {
        _check_pread_simple(fd, contents, scenario, true);
    }
    CHECK_TEST_SET();
    if (fd >= 0) {
        fat_close(fd);
    }
    START_TEST_SET("simple open+read+size", scenario);
    fd = fat_open(path);
    CHECK(fd >= 0, "opening " << path);
    if (fd >= 0) {
        _check_pread_simple(fd, contents, scenario, false);
    }
    CHECK_TEST_SET();
    if (!only_simple) {
        check_pread_ranges(fd, contents, scenario, true);
        check_pread_ranges(fd, contents, scenario, false);
    }
    if (fd >= 0) {
        fat_close(fd);
    }
}

void check_contents(const std::string &path, const std::string &contents, bool only_simple = true) {
    fork_and_run(
        std::bind(&_check_contents, path, contents, only_simple)
    );
}

void _check_contents_prefix(const std::string &path, const std::string &contents_prefix) {
    std::string scenario = "path="+path;
    START_TEST_SET("simple open+read beginning", scenario);
    int fd = fat_open(path);
    CHECK(fd >= 0, "opening " << path);
    if (fd >= 0) {
        _check_pread_simple(fd, contents_prefix, scenario, false);
    }
    CHECK_TEST_SET();
    if (fd >= 0) {
        fat_close(fd);
    }
}

void check_contents_prefix(const std::string &path, const std::string &contents) {
    fork_and_run(
        std::bind(&_check_contents_prefix, path, contents)
    );
}

void _check_not_openable(const std::string &path, const std::string & scenario = "") {
    START_TEST_SET("failed open", scenario);
    int fd = fat_open(path);
    CHECK(fd == -1, "opening " << path << " should fail");
    if (fd >= 0) {
        fat_close(fd);
    }
    CHECK_TEST_SET();
}

void check_not_openable(const std::string &path, const std::string & scenario) {
    fork_and_run(
        std::bind(&_check_not_openable, path, scenario)
    );
}

void _check_not_readdir(const std::string & path, const std::string & scenario) {
    START_TEST_SET("failed readdir", scenario);
    CHECK(fat_readdir(path).size() == 0, "cannot readdir " << path);
    CHECK_TEST_SET();
}

void check_not_readdir(const std::string &path, const std::string & scenario) {
    fork_and_run(
        std::bind(&_check_not_readdir, path, scenario)
    );
}

void a1_test(void) {
    check_b4("/a1/b1/b2/b3/b4");
    check_contents("/a1/b1/b2/b3/b4/example9.txt", "This is example 9.\n");
}

void a2_test(void) {
    check_a2("/a2");
    check_contents("/a2/example3.txt", "the contents of example3.txt\n");
}

void mounted_tests(void) {
    bool mounted = fat_mount("testdisk1.raw");
    CHECK(mounted, "mounting testdisk1.raw successful");
    if (!mounted) {
        myout << "could not mount testdisk1.raw, skipping rest of tests\n";
        myout << "(is that file in this directory?)\n";
        myout << std::flush;
        _Exit(1);
    }
    check_root_dir("/");
    check_root_dir("/", true);
    check_contents("/congrats.txt", CONGRATS_TEXT, false);
    check_contents("/congrAts.tXt", CONGRATS_TEXT);
    check_contents("/congrats.tXt", CONGRATS_TEXT);
    check_contents("/CONGRATS.TXT", CONGRATS_TEXT);
    check_contents("/example1.txt", "the contents of example1.\n");
    check_contents("/gamecopy.txt", THE_GAME_TEXT, false);
    check_contents("/gamecopy.txt", THE_GAME_TEXT);
    check_contents("/gamefrag.txt", THE_GAME_TEXT, false);
    check_contents("/gamefrag.txt", THE_GAME_TEXT);
    check_contents("/foo.a", "simple file\n");
    check_contents("/foo.ba", "simple file 2\n");
    check_people_dir("/people");
    check_contents("/people/example2.txt", "The contents of example2.\n");
    check_contents("/people/example2.txt", "The contents of example2.\n");
    check_contents_prefix("/media/404-fail.jpg", 
        std::string(
            (char*) jpg_404_fail_beginning,
            (char*) jpg_404_fail_beginning + sizeof(jpg_404_fail_beginning)
        )
    );
    check_a2("/a2");
    check_a99("/a99");
    check_contents("/a99/foo.xx", "simple file 3\n");
    check_contents("/a99/congrats.txt", CONGRATS_TEXT);
    check_contents("/a99/new-game.txt", THE_GAME_TEXT);
    check_contents("/example1.txt", "the contents of example1.\n");
    check_contents("/a2/example3.txt", "the contents of example3.txt\n");
    check_root_dir("/people/..");
    check_root_dir("/PEoPLE/..");
    check_root_dir("/Media/..");
    check_contents("/a1/b1/b2/b3/b4/example9.txt", "This is example 9.\n");
    check_contents("/a1/b1/b2/b3/example6.txt", "This is example 6.\n");
    check_b4("/a1/b1/b2/b3/b4");
    check_contents("/people/../congrats.txt", CONGRATS_TEXT);
    check_contents("/people/../people/../people/../people/../congrats.txt", CONGRATS_TEXT);
    check_contents("/people/yyz5w/the-game.txt", THE_GAME_TEXT, false);
    check_people_dir("/media/../people/smb3wk/..");
    check_people_dir("/people/smb3wk/..");
    check_people_dir("/people/yyz5w/..");
    check_yyz5w_dir("/people/yyz5w");
    check_yyz5w_dir("/people/yyz5w/../yyz5w");
    START_TEST_SET("multiple file descriptors", "");
    int fd_one = fat_open("/congrats.txt");
    int fd_two = fat_open("/example1.txt");
    _check_pread_simple(fd_one, CONGRATS_TEXT, "/congrats.txt");
    _check_pread_simple(fd_two, "the contents of example1.\n", "/example1.txt");
    fat_close(fd_one);
    fat_close(fd_two);
    CHECK_TEST_SET();
    fork_and_run(a1_test);
    fork_and_run(a2_test);
}

void premount_tests() {
    check_not_openable("/congrats.txt", "opening file before mount");
    check_not_readdir("/", "readdir before mount");
}
}

int main(int argc, char **argv) {
    myout.open("/dev/fd/1");
#ifdef HIDE_STDOUT
    int fd = open("/dev/null", O_RDWR);
    dup2(fd, 1);
    dup2(fd, 2);
#endif
    fork_and_run(premount_tests, big_timeout);
    mounted_tests();
#ifndef GRADING_OUTPUT
    myout << "Passed " << passed_groups << " test groups and failed " << failed_groups << " test groups\n";
    myout << "(by passing " << passed_total << " subtests and failing " << failed_total << " subtests)\n\n";
    myout << "Note that the number of tests/subtests is not a very good indication of how\n"
             "much you've completed; for example there several tests reading\n"
             "from many offsets in a file; all of these will likely only be one\n"
             "item on our grading rubric, while failing a small number of tests\n"
             "related to reading the root directory indicates a more serious\n"
             "problem.\n\n"
             "Also, please be aware we may run additional tests, including tests with\n"
             "a different disk image for grading.\n" << std::endl;
#endif
}
